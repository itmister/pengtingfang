<style> hr{ height:2px;border:none;border-top:2px dotted #185598;  } </style>
<?php header( 'Content-Type:text/html;charset=utf-8 '); echo "<pre>";
/*
 * http://www.jb51.net/article/14049.htm
 * http://www.cnblogs.com/anxuexi/archive/2013/03/26/2982791.html 表
 *
非打印字符:
\cx  匹配由x指明的控制字符。例如， \cM 匹配一个 Control-M 或回车符。x 的值必须为 A-Z 或 a-z 之一。否则，将 c 视为一个原义的 'c' 字符。
\f  匹配一个换页符。等价于 \x0c 和 \cL。
\n  匹配一个换行符。等价于 \x0a 和 \cJ。
\r  匹配一个回车符。等价于 \x0d 和 \cM。
\s  匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。
\S  匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\t  匹配一个制表符。等价于 \x09 和 \cI。
\v  匹配一个垂直制表符。等价于 \x0b 和 \cK。
\w  [a-zA-Z0-9_]
\d  [0-9]
\b  定位符规定匹配模式必须出现在目标字符串的开头或结尾的两个边界之一
\B  定位符则规定匹配对象必须位于目标字符串的开头和结尾两个边界之内

限定符（特殊字符）:
^  表示匹配的字符必须在最前边，除非在方括号表达式中使用，此时它表示不接受该字符集合。要匹配 ^ 字符本身，请使用 \^。
$  与^类似，匹配最末的字符。如果设置了 RegExp 对象的 Multiline 属性，则 $ 也匹配 '\n' 或 '\r'。要匹配 $ 字符本身，请使用 \$。
( )  标记一个子表达式的开始和结束位置。子表达式可以获取供以后使用。要匹配这些字符，请使用 \( 和 \)。
*  等价于{0,}，0到多次。
+  等价于{1,}，1次或n次。
?  等价于{0,1}，0或1次。
.  匹配除换行符 \n之外的任何单字符。要匹配 .，请使用 \。
[  标记一个中括号表达式的开始。要匹配 [，请使用 \[。
\  将下一个字符标记为或特殊字符、或原义字符、或向后引用、或八进制转义符。例如， 'n' 匹配字符 'n'。'\n' 匹配换行符。序列 '\\' 匹配 "\"，而 '\(' 则匹配 "("。
{3,5}表示3到5个字符。{3,}超过3个字符，{,5}最多5个，{3}三个字符。

修饰符:
i: 不区分大小写

/*

mixed preg_replace( mixed pattern, mixed replacement, mixed subject [, int limit ] )

int preg_match ( string pattern, string subject [, array matches [, int flags]] ) 返回 pattern 所匹配的次数。要么是 0 次（没有匹配）或 1 次，因为 preg_match() 在第一次匹配之后将停止搜索。
int preg_match_all(string 正则,string 字符串，array 匹配值，[标记])    则相反，会一直搜索到 subject 的结尾处。如果出错 preg_match() 返回 FALSE
preg_quote(string str [, string delimiter])     以 str 为参数并给其中每个属于正则表达式语法的字符前面加上一个反斜线。如果你需要以动态生成的字符串作为模式去匹配则可以用此函数转义其中可能包含的特殊字符。

*/



echo "<h1 style=\"text-align:center\">基础</h1>";

if (preg_match ("/正/", "包含正"))
    echo "定界符 / ：/正/ ---------- // 正则表达式， 包含正<hr/>";

if (preg_match ("/\/正/", "包含/正"))
    echo "定界符 \ ：/\/正/ ---------- 将下一个字符标记为一个特殊字符<hr/>";

if (preg_match ("/^正/", "正则开始"))
    echo "元字符 ^ ：/^正/ ---------- 必须'正'字开头 ---------- 表示匹配的字符必须在最前边<hr/>";

if (preg_match ("/正$/", "啦啦正"))
    echo "元字符 $ ：/正$/ ---------- 必须'正'字结束 ---------- 与^类似，匹配最末的字符<hr/>";

if (preg_match ("/正*/", "表达式正"))
    echo "元字符 * ：/正*/ ---------- '正'字出现0或多次 ---------- 匹配*前面的字符0次或n次,等价于{0,}<hr/>";

if (preg_match ("/正+/", "正则表达式"))
    echo "元字符 + ：/正+/ ---------- '正'字出现1或多次 ---------- 匹配+前面的字符1次或n次,等价于{1,}<hr/>";

if (preg_match ("/正?/", "则表达式"))
    echo "元字符 ? ：/正+/ ---------- '正'字出现1或多次 ---------- 匹配?前面的字符0次或1次,等价于{0,1},PS: “正+?”将匹配单个“正”，而“正+”将匹配所有“正”<hr/>";

if (preg_match ("/正./", "正则表达式"))
    echo "元字符 . ：/正./ ---------- '正'后面的任何单字符 ---------- 匹配除换行符 \\n之外的任何单字符<hr/>";

if (preg_match ("/x|y/", "xzz"))
    echo "元字符 | ：/x|y/ ----------  x 或者 y ---------- 或者， 的意思.匹配前后 <hr/>";

if (preg_match ("/[1-5]/", "4"))
    echo "元字符 [] ：/[1-5]/ ----------  1-5的数字 ---------- 字符集合，标记一个中括号（范围）表达式的开始，列表方式：[asdf] 字母方式：[a-z]。<hr/>";

if (preg_match ("/[^1-5]/", "6"))
    echo "元字符 [^] ：/[^1-5]/ ----------  不能1-5的数字 ---------- 非字符集，合标记一个中括号（范围）表达式的开始，列表方式：[asdf] 字母方式：[a-z]。<hr/>";

if (preg_match ("/a{2,5}/", "bbaaaccc"))
    echo "元字符 {} ：/a{2,5}/ ----------  a出现2到5次 ---------- 标记一个花括号前字符出现的次数.PS:{3,5}表示3到5个字符。{3,}超过3个字符，{,5}最多5个，{3}三个字符。<hr/>";

if (preg_match ("/(ab){2,5}/", "abababa"))
    echo "元字符 () ：/(ab){2,5}/ ----------  ab出现2到5次 ---------- 子表达式,匹配并获取。结果数组中的元素[1], ..., [n] 返回，或被RegExp对象的属性$1, ..., $9返回。 <hr/>";

if (preg_match ("/(?:ab){2,5}/", "abababa"))
    echo "元字符 (?:) ：/(?:ab){2,5}/ ----------  ab出现2到5次 ---------- 子表达式,匹配<b>不获取</b>。这在使用或字符“(|)”来组合一个模式的各个部分是很有用。例如“industr(?:y|ies)”就是一个比“industry|industries”更简略的表达式。 <hr/>";

if (preg_match ("/Windows(?=95|98|NT|2000)/", "Windows95"))
    echo "元字符 (?=) ：/Windows(?=95|98|NT|2000)/ ---------- Windows后的是 95|98|NT|2000 ---------- 正 向肯定预查，不获取，预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 <hr/>";

if (preg_match ("/Windows(?!95|98|NT|2000)/", "Windows3.1"))
    echo "元字符 (?!) ：/Windows(?!95|98|NT|2000)/ ---------- Windows后的不能是 95|98|NT|2000 ---------- 正 向否定预查，不获取，预查不消耗字符，也就是说，在一个匹配发生后，在最后一次匹配之后立即开始下一次匹配的搜索，而不是从包含预查的字符之后开始。 <hr/>";

if (preg_match ("/(?<=95|98|NT|2000)Windows/", "98Windows"))
    echo "元字符 (?<=) ：/(?<=95|98|NT|2000)Windows/ ---------- Windows前的是 95|98|NT|2000 ---------- 反 向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?<=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 <hr/>";

if (preg_match ("/(?<!95|98|NT|2000)Windows/", "2008Windows"))
    echo "元字符 (?<:) ：/(?<！95|98|NT|2000)Windows/ ---------- Windows不前的是 95|98|NT|2000 ---------- 反 向肯定预查，与正向肯定预查类似，只是方向相反。例如，“(?<=95|98|NT|2000)Windows”能匹配“2000Windows”中的“Windows”，但不能匹配“3.1Windows”中的“Windows”。 <hr/>";

if (preg_match ("/er\b/", "never"))
    echo "元字符 \b ：/er\b/ ---------- er右边是空格或没有 ---------- 匹配一个单词边界，也就是指单词和空格间的位置。例如，“er\b”可以匹配“never”中的“er”，但不能匹配“verb”中的“er”。<hr/>";

if (preg_match ("/er\B/", "never1"))
    echo "元字符 \B ：/er\b/ ---------- er右边不能空 ---------- 匹配非单词边界。“er\B”能匹配“verb”中的“er”，但不能匹配“never”中的“er”。<hr/>";

if (preg_match ("/\cM/", "\r"))
    echo "元字符 \cx ： /\cM/ ---------- 匹配由x指明的控制字符。例如，\cM匹配一个Control-M或回车符。x的值必须为A-Z或a-z之一。否则，将c视为一个原义的“c”字符。<hr/>";

if (preg_match ("/\d/", "1"))
    echo "元字符 \d ： /\d/ ---------- 匹配一个数字字符。等价于[0-9]。<hr/>";

if (preg_match ("/\D/", "a1"))
    echo "元字符 \D ： /\D/ ---------- 匹配一个非数字字符。等价于[^0-9]。<hr/>";

if (preg_match ("/\w/", "12ab_"))
    echo "元字符 \w ： /\w/ ---------- 匹配包括下划线的任何单词字符。等价于“[A-Za-z0-9_]”。<hr/>";

if (preg_match ("/\W/", "12ab_"))
    echo "元字符 \W ： /\W/ ---------- 匹配任何非下划线的任何单词字符。等价于“[^A-Za-z0-9_]”。<hr/>";

if (preg_match ("/\f/", "\f"))
    echo "元字符 \ f ： /\ f/ ---------- 匹配一个换页符。等价于\x0c和\cL。<hr/>";

if (preg_match ("/\n/", "\n"))
    echo "元字符 \ n ： /\ n/ ---------- 匹配一个换行符。等价于\ x0a和\cJ。<hr/>";

if (preg_match ("/\r/", "\r"))
    echo "元字符 \ r ： /\ r/ ---------- 匹配一个回车符。等价于\ x0d和\cM。<hr/>";

if (preg_match ("/\s/", "\r"))
    echo "元字符 \s ： /\s/ ---------- 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[ \ f    \ n   \ r  \ t   \ v]<hr/>";

if (preg_match ("/\S/", "\1"))
    echo "元字符 \S ： /\S/ ---------- 匹配任何空白字符，包括空格、制表符、换页符等等。等价于[^ \ f    \ n   \ r  \ t   \ v]<hr/>";

if (preg_match ("/\t/", "\t"))
    echo "元字符 \ t ： /\ t/ ---------- 匹配一个水平制表符。等价于\ x09和\cI。<hr/>";

if (preg_match ("/\v/", "\v"))
    echo "元字符 \ v ： /\ v/ ---------- 匹配一个垂直制表符。等价于\ x0b和\cK。<hr/>";

if (preg_match ("/\x41/", "A"))
    echo "元字符 \xn ： /\xn/ ---------- 匹配n，其中n为十六进制转义值。十六进制转义值必须为确定的两个数字长。例如，“\x41”匹配“A”。“\x041”则等价于“\x04&1”。正则表达式中可以使用ASCII编码。<hr/>";

if (preg_match ("/(.)\\1(\w)\\2/", "aabb11"))
    echo "元字符 \ num ： /\ num/ ---------- 匹配num，其中num是一个正整数。对所获取的匹配的引用。例如，“(.)\1”匹配两个连续的相同字符。<hr/>";

if (1==1)
    echo "元字符 \ n ： /\ n/ ---------- 标识一个八进制转义值或一个向后引用。如果\ n之前至少n个获取的子表达式，则n为向后引用。否则，如果n为八进制数字（0-7），则n为一个八进制转义值。<hr/>";

if (1==1)
    echo "元字符 \ nm ： /\ nm/ ---------- 标识一个八进制转义值或一个向后引用。如果\ nm之前至少有nm个获得子表达式，则nm为向后引用。如果\ nm之前至少有n个获取，则n为一个后跟文字m的向后引用。如果前面的条件都不满足，若n和m均为八进制数字（0-7），则\ nm将匹配八进制转义值nm。<hr/>";

//if (preg_match ("/\u00a9/", "?"))
if(1==1)
    echo "元字符 \ nml ： /\ nml/ ---------- 如果n为八进制数字（0-3），且m和l均为八进制数字（0-7），则匹配八进制转义值nml。<hr/>";

//if (preg_match ("/\u00AB/", "«"))
if(1==1)
    echo "元字符 \un ： /\un/ ----------  匹配n，其中n是一个用四个十六进制数字表示的Unicode字符。例如，\u00A9匹配版权符号（©）。<hr/>";


echo "<h1 style=\"text-align:center\">常用</h1>";

if (preg_match ("/^[1-9]\d*$/", "111"))
    echo "匹配正整数：/^[1-9]\d*$/ <hr/>";


if (preg_match ("/^[1-9]\d*$/", "111"))
    echo "匹配正整数：/^[1-9]\d*$/ <hr/>";

if (preg_match ("/^-[1-9]\d*$/", "-111"))
    echo "匹配负整数：/^-[1-9]\d*$/<hr/>";

if (preg_match ("/^-?[1-9]\d*$/", "-111"))
    echo "匹配整数：/^-?[1-9]\d*$/ <hr/>";

if (preg_match ("/Php/i", "PhP is the web scripting language of choice."))
    echo "/Php/i ---------- 匹配了Php不区分大小写 ---------- 模式定界符后面的 \"i\" 表示不区分大小写字母的搜索<hr/>";

if (preg_match ("/^a(bc|cb){2,5}d+e*f?z$/", "abccbddefz"))
    echo "/a(bc|cb){2,5}/ ---------- 匹配了1-5次bc ---------- ^ 开头 ()表达式,{}匹配前面的次数, | 表达式中的或者，+ 前字符1次或n次 ，? 前字符0或1次 ， $ 结尾<hr/>";

if (preg_match ("/\bweb\b/i", "PHP is wEb scripting language of choice."))
    echo "/\bweb\b/i ---------- 匹配了单词web，不区分大小写 中文不可用 ----------  \b 表示单词的边界，因此只有独立的 \"web\" ，单词会被匹配而不会匹配例如 \"webbing\" 或 \"cobweb\" 中的一部分, \B 相反 <hr/>";

if (preg_match("/^([a-zA-Z0-9])+([.a-zA-Z0-9_-])*@([.a-zA-Z0-9_-])+([.a-zA-Z0-9_-]+)+([.a-zA-Z0-9_-])$/","784643582@qq.com"))
    echo '匹配邮箱： /^([a-zA-Z0-9])+([.a-zA-Z0-9_-])*@([.a-zA-Z0-9_-])+([.a-zA-Z0-9_-]+)+([.a-zA-Z0-9_-])$/ <hr/>';

if(preg_match("/^[1-9][0-9]{4,10}$/" , "784643582" ))
    echo '匹配QQ： /^[1-9][0-9]{4,10}$/<hr/>';
//必须包含大写字母+小写字母+数字
//preg_match('/(?=.*[A-Z])(?=.*[a-z])(?=.*[0-9])[A-Za-z0-9]{8,20}/',$password);

/* 从主机名中取得后面两段 */
preg_match("/^(http:\/\/)?([^\/]+)/i","http://www.php.net/index.html", $matches);
preg_match("/[^\.\/]+\.[^\.\/]+$/", $matches[2], $matches);
echo "URL中取得主机名: {$matches[0]}/^(http:\/\/)?([^\/]+)/i   /[^\.\/]+\.[^\.\/]+$/ <hr/>";

$str = "php点点通是一个学习php的网站，(⊙o⊙)…";
echo preg_quote($str);
echo "<hr />";